using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis;
using Spectre.Console.Cli.SourceGenerator.Model;

namespace Spectre.Console.Cli.SourceGenerator.Emitters;

/// <summary>
/// Emitter that generates a wrapper class with DynamicDependency attributes
/// to preserve types for AOT-safe reflection.
/// </summary>
internal static class MetadataContextEmitter
{
    // Intrinsic types that don't need DynamicDependency (trimmer preserves them automatically)
    private static readonly HashSet<string> IntrinsicTypes = new(StringComparer.Ordinal)
    {
        "bool", "System.Boolean", "global::System.Boolean",
        "byte", "System.Byte", "global::System.Byte",
        "sbyte", "System.SByte", "global::System.SByte",
        "short", "System.Int16", "global::System.Int16",
        "ushort", "System.UInt16", "global::System.UInt16",
        "int", "System.Int32", "global::System.Int32",
        "uint", "System.UInt32", "global::System.UInt32",
        "long", "System.Int64", "global::System.Int64",
        "ulong", "System.UInt64", "global::System.UInt64",
        "float", "System.Single", "global::System.Single",
        "double", "System.Double", "global::System.Double",
        "decimal", "System.Decimal", "global::System.Decimal",
        "char", "System.Char", "global::System.Char",
        "string", "System.String", "global::System.String",
        "object", "System.Object", "global::System.Object",
        "System.DateTime", "global::System.DateTime",
        "System.DateTimeOffset", "global::System.DateTimeOffset",
        "System.TimeSpan", "global::System.TimeSpan",
        "System.Guid", "global::System.Guid",
        "System.Uri", "global::System.Uri",
    };

    /// <summary>
    /// Emits a partial class that wraps ReflectionMetadataContext with DynamicDependency attributes.
    /// </summary>
    public static string EmitPartial(
        TargetTypeModel targetType,
        List<SettingsTypeModel> settingsTypes,
        List<CommandTypeModel> commandTypes,
        GenericTypeInfo genericTypes)
    {
        var sb = new StringBuilder();
        using var stringWriter = new StringWriter(sb);
        using var writer = new IndentedTextWriter(stringWriter, "    ");

        // File header
        writer.WriteLine("// <auto-generated />");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();
        writer.WriteLine("// Suppress ILLink warnings - types are preserved via DynamicDependency attributes on the constructor");
        writer.WriteLine("#pragma warning disable IL2026 // RequiresUnreferencedCode");
        writer.WriteLine("#pragma warning disable IL2067 // DynamicallyAccessedMembers - parameter types preserved via DynamicDependency");
        writer.WriteLine("#pragma warning disable IL2092 // DynamicallyAccessedMembers - implementation differs from interface intentionally");
        writer.WriteLine("#pragma warning disable IL3050 // RequiresDynamicCode");
        writer.WriteLine();

        // User's namespace (or file-scoped if global)
        bool hasNamespace = !string.IsNullOrEmpty(targetType.Namespace);
        if (hasNamespace)
        {
            writer.WriteLine($"namespace {targetType.Namespace}");
            writer.WriteLine("{");
            writer.Indent++;
        }

        // Collect all types that need DynamicDependency
        var allTypes = CollectTypesForDynamicDependency(settingsTypes, commandTypes, genericTypes);

        // Emit the partial class
        var accessModifier = GetAccessModifier(targetType.Accessibility);
        EmitClassDocumentation(writer, settingsTypes, commandTypes);

        writer.WriteLine($"[global::System.CodeDom.Compiler.GeneratedCode(\"Spectre.Console.Cli.SourceGenerator\", \"1.0.0\")]");
        writer.WriteLine($"{accessModifier} partial class {targetType.Name} : global::Spectre.Console.Cli.Metadata.ICommandMetadataContext");
        writer.WriteLine("{");
        writer.Indent++;

        // Emit the wrapper implementation with DynamicDependency on constructor
        EmitWrapperImplementation(writer, targetType.Name, allTypes, genericTypes);

        writer.Indent--;
        writer.WriteLine("}");

        if (hasNamespace)
        {
            writer.Indent--;
            writer.WriteLine("}");
        }

        return sb.ToString();
    }

    private static Dictionary<string, string> CollectTypesForDynamicDependency(
        List<SettingsTypeModel> settingsTypes,
        List<CommandTypeModel> commandTypes,
        GenericTypeInfo genericTypes)
    {
        var types = new Dictionary<string, string>(StringComparer.Ordinal);

        // Settings types need All (properties, constructors, attributes)
        foreach (var settings in settingsTypes)
        {
            types[settings.FullyQualifiedName] = "All";

            // Add non-intrinsic property types
            foreach (var prop in settings.Properties)
            {
                AddPropertyTypeDependencies(types, prop);
            }
        }

        // Command types need All (type info, attributes, interfaces)
        foreach (var command in commandTypes)
        {
            types[command.FullyQualifiedName] = "All";
        }

        // Custom type converters need PublicConstructors
        foreach (var converterType in genericTypes.ConverterTypes)
        {
            if (!types.ContainsKey(converterType))
            {
                types[converterType] = "PublicConstructors";
            }
        }

        // Custom pair deconstructors need PublicConstructors
        foreach (var deconstructorType in genericTypes.PairDeconstructorTypes)
        {
            if (!types.ContainsKey(deconstructorType))
            {
                types[deconstructorType] = "PublicConstructors";
            }
        }

        // Custom value providers need PublicConstructors
        foreach (var valueProviderType in genericTypes.ValueProviderTypes)
        {
            if (!types.ContainsKey(valueProviderType))
            {
                types[valueProviderType] = "PublicConstructors";
            }
        }

        // Note: MultiMap<,> and FlagValue<> generic types are preserved via string-based
        // DynamicDependency in EmitWrapperImplementation since MultiMap is internal.
        // Arrays of element types are handled here.
        foreach (var arrayElementType in genericTypes.ArrayElementTypes)
        {
            // Arrays use element type array syntax: typeof(string[])
            var arrayType = $"{arrayElementType}[]";
            if (!types.ContainsKey(arrayType))
            {
                types[arrayType] = "All";
            }
        }

        return types;
    }

    private static void AddPropertyTypeDependencies(Dictionary<string, string> types, PropertyModel prop)
    {
        // Add the property type itself if not intrinsic
        AddTypeIfNotIntrinsic(types, prop.PropertyTypeName, "All");

        // Add array element type if present
        if (prop.ArrayElementTypeName != null && !string.IsNullOrEmpty(prop.ArrayElementTypeName))
        {
            AddTypeIfNotIntrinsic(types, prop.ArrayElementTypeName, "All");
        }

        // Add FlagValue inner type if present
        if (prop.FlagValueInnerTypeName != null && !string.IsNullOrEmpty(prop.FlagValueInnerTypeName))
        {
            AddTypeIfNotIntrinsic(types, prop.FlagValueInnerTypeName, "All");
        }

        // Add dictionary key/value types if present
        if (prop.DictionaryKeyTypeName != null && !string.IsNullOrEmpty(prop.DictionaryKeyTypeName))
        {
            AddTypeIfNotIntrinsic(types, prop.DictionaryKeyTypeName, "All");
        }

        if (prop.DictionaryValueTypeName != null && !string.IsNullOrEmpty(prop.DictionaryValueTypeName))
        {
            AddTypeIfNotIntrinsic(types, prop.DictionaryValueTypeName, "All");
        }
    }

    private static void AddTypeIfNotIntrinsic(Dictionary<string, string> types, string typeName, string memberTypes)
    {
        if (string.IsNullOrEmpty(typeName))
        {
            return;
        }

        // Handle nullable types (e.g., "int?" or "System.Nullable<int>")
        var cleanTypeName = typeName.TrimEnd('?');
        if (cleanTypeName.StartsWith("System.Nullable<", StringComparison.Ordinal) ||
            cleanTypeName.StartsWith("global::System.Nullable<", StringComparison.Ordinal))
        {
            // Extract the inner type
            var start = cleanTypeName.IndexOf('<') + 1;
            var end = cleanTypeName.LastIndexOf('>');
            if (start > 0 && end > start)
            {
                cleanTypeName = cleanTypeName.Substring(start, end - start);
            }
        }

        if (IsIntrinsicType(cleanTypeName))
        {
            return;
        }

        if (!types.ContainsKey(typeName))
        {
            types[typeName] = memberTypes;
        }
    }

    private static bool IsIntrinsicType(string typeName)
    {
        return IntrinsicTypes.Contains(typeName) ||
               IntrinsicTypes.Contains(typeName.TrimEnd('?'));
    }

    private static void EmitWrapperImplementation(IndentedTextWriter writer, string className, Dictionary<string, string> allTypes, GenericTypeInfo genericTypes)
    {
        // Private field holding the reflection context
        writer.WriteLine("private readonly global::Spectre.Console.Cli.Internal.Metadata.ReflectionMetadataContext _context;");
        writer.WriteLine();

        // Note: MultiMap and FlagValue instantiations are preserved via direct `new` calls
        // in CreateMultiMap and CreateFlagValue methods below - no DynamicDependency needed.

        // Note: Built-in internal commands (VersionCommand, XmlDocCommand, etc.) are preserved
        // by the library itself via BuiltInCommandMetadata which directly references them.
        // We only emit DynamicDependency for public types that users may use.
        writer.WriteLine("[global::System.Diagnostics.CodeAnalysis.DynamicDependency(global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All, typeof(global::Spectre.Console.Cli.EmptyCommandSettings))]");

        // Constructor with DynamicDependency attributes for discovered types
        foreach (var kvp in allTypes.OrderBy(t => t.Key))
        {
            var typeName = kvp.Key;

            // Skip interface types - we preserve the concrete MultiMap<,> type instead
            if (IsInterfaceType(typeName))
            {
                continue;
            }

            // Check if this is an assembly-qualified type name
            // e.g., "MyNamespace.MyConverter, MyAssembly"
            // Must have comma that's NOT inside generic type parameters
            if (IsAssemblyQualifiedName(typeName))
            {
                var commaIndex = FindAssemblyQualifierComma(typeName);
                var typeNamePart = typeName.Substring(0, commaIndex).Trim();
                var assemblyNamePart = typeName.Substring(commaIndex + 1).Trim();
                writer.WriteLine($"[global::System.Diagnostics.CodeAnalysis.DynamicDependency(global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.{kvp.Value}, \"{typeNamePart}\", \"{assemblyNamePart}\")]");
            }
            else
            {
                writer.WriteLine($"[global::System.Diagnostics.CodeAnalysis.DynamicDependency(global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.{kvp.Value}, typeof({typeName}))]");
            }
        }

        // Suppress ILC trim/AOT analysis warnings - DynamicDependency preserves all required types
        writer.WriteLine("[global::System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage(\"Trimming\", \"IL2026:RequiresUnreferencedCode\", Justification = \"Types are preserved via DynamicDependency attributes on this constructor.\")]");
        writer.WriteLine("[global::System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessage(\"AOT\", \"IL3050:RequiresDynamicCode\", Justification = \"Types are preserved via DynamicDependency attributes on this constructor.\")]");
        writer.WriteLine($"public {className}()");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine("_context = new global::Spectre.Console.Cli.Internal.Metadata.ReflectionMetadataContext();");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();

        // CreateSettings method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public global::Spectre.Console.Cli.CommandSettings CreateSettings(global::System.Type settingsType)");
        writer.WriteLine("    => _context.CreateSettings(settingsType);");
        writer.WriteLine();

        // GetSettingsMetadata method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public global::Spectre.Console.Cli.Metadata.ISettingsMetadata GetSettingsMetadata(global::System.Type settingsType)");
        writer.WriteLine("    => _context.GetSettingsMetadata(settingsType);");
        writer.WriteLine();

        // GetCommandTypeMetadata method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public global::Spectre.Console.Cli.Metadata.ICommandTypeMetadata? GetCommandTypeMetadata(global::System.Type commandType)");
        writer.WriteLine("    => _context.GetCommandTypeMetadata(commandType);");
        writer.WriteLine();

        // GetSettingsTypeForCommand method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public global::System.Type? GetSettingsTypeForCommand(global::System.Type commandType)");
        writer.WriteLine("    => _context.GetSettingsTypeForCommand(commandType);");
        writer.WriteLine();

        // CreatePairDeconstructor method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public object CreatePairDeconstructor(global::System.Type deconstructorType)");
        writer.WriteLine("    => _context.CreatePairDeconstructor(deconstructorType);");
        writer.WriteLine();

        // CreateDefaultValue method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public object? CreateDefaultValue(global::System.Type valueType)");
        writer.WriteLine("    => _context.CreateDefaultValue(valueType);");
        writer.WriteLine();

        // CreateInstance method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public object CreateInstance(global::System.Type type)");
        writer.WriteLine("    => _context.CreateInstance(type);");
        writer.WriteLine();

        // GetTypeConverter method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public global::System.ComponentModel.TypeConverter GetTypeConverter(global::System.Type type)");
        writer.WriteLine("    => _context.GetTypeConverter(type);");
        writer.WriteLine();

        // CreateFlagValue method - direct instantiation for AOT safety
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public global::Spectre.Console.Cli.IFlagValue CreateFlagValue(global::System.Type underlyingType)");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var flagType in genericTypes.FlagValueTypes)
        {
            writer.WriteLine($"if (underlyingType == typeof({flagType}))");
            writer.Indent++;
            writer.WriteLine($"return new global::Spectre.Console.Cli.FlagValue<{flagType}>();");
            writer.Indent--;
        }
        writer.WriteLine("throw new global::System.InvalidOperationException($\"Unknown FlagValue type: FlagValue<{underlyingType}>. Ensure the type is used in a settings class with [SpectreMetadata].\");");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();

        // CreateMultiMap method - direct instantiation for AOT safety
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public global::Spectre.Console.Cli.IMultiMap CreateMultiMap(global::System.Type keyType, global::System.Type valueType)");
        writer.WriteLine("{");
        writer.Indent++;
        foreach (var multiMapType in genericTypes.MultiMapTypes)
        {
            writer.WriteLine($"if (keyType == typeof({multiMapType.KeyType}) && valueType == typeof({multiMapType.ValueType}))");
            writer.Indent++;
            writer.WriteLine($"return new global::Spectre.Console.Cli.MultiMap<{multiMapType.KeyType}, {multiMapType.ValueType}>();");
            writer.Indent--;
        }
        writer.WriteLine("throw new global::System.InvalidOperationException($\"Unknown MultiMap type: MultiMap<{keyType}, {valueType}>. Ensure the type is used in a settings class with [SpectreMetadata].\");");
        writer.Indent--;
        writer.WriteLine("}");
        writer.WriteLine();

        // ConvertWithConstructorFallback method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public object? ConvertWithConstructorFallback(global::System.Type targetType, object input)");
        writer.WriteLine("    => _context.ConvertWithConstructorFallback(targetType, input);");
        writer.WriteLine();

        // RegisterKnownTypes method
        writer.WriteLine("/// <inheritdoc />");
        writer.WriteLine("public void RegisterKnownTypes(global::Spectre.Console.Cli.ITypeRegistrar registrar, global::Spectre.Console.Cli.Help.ICommandModel model)");
        writer.WriteLine("    => _context.RegisterKnownTypes(registrar, model);");
    }

    private static void EmitClassDocumentation(
        IndentedTextWriter writer,
        List<SettingsTypeModel> settingsTypes,
        List<CommandTypeModel> commandTypes)
    {
        writer.WriteLine("/// <summary>");
        writer.WriteLine("/// Generated AOT-safe metadata context for Spectre.Console.Cli.");
        writer.WriteLine("/// This class uses DynamicDependency attributes to preserve type metadata for reflection.");
        writer.WriteLine("/// </summary>");
        if (settingsTypes.Count > 0 || commandTypes.Count > 0)
        {
            writer.WriteLine("/// <remarks>");
            if (settingsTypes.Count > 0)
            {
                writer.WriteLine("/// <para><b>Discovered settings types:</b></para>");
                writer.WriteLine("/// <list type=\"bullet\">");
                foreach (var settings in settingsTypes)
                {
                    var description = !string.IsNullOrEmpty(settings.Description)
                        ? $" - {EscapeXmlComment(settings.Description ?? string.Empty)}"
                        : string.Empty;
                    writer.WriteLine($"/// <item><description><see cref=\"{settings.FullyQualifiedName.Replace("global::", "")}\"/>{description}</description></item>");
                }
                writer.WriteLine("/// </list>");
            }
            if (commandTypes.Count > 0)
            {
                writer.WriteLine("/// <para><b>Discovered command types:</b></para>");
                writer.WriteLine("/// <list type=\"bullet\">");
                foreach (var command in commandTypes)
                {
                    var description = !string.IsNullOrEmpty(command.Description)
                        ? $" - {EscapeXmlComment(command.Description ?? string.Empty)}"
                        : string.Empty;
                    writer.WriteLine($"/// <item><description><see cref=\"{command.FullyQualifiedName.Replace("global::", "")}\"/>{description}</description></item>");
                }
                writer.WriteLine("/// </list>");
            }
            writer.WriteLine("/// </remarks>");
        }
    }

    private static string GetAccessModifier(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.Private => "private",
            _ => "internal"
        };
    }

    /// <summary>
    /// Escapes special characters for XML comments.
    /// </summary>
    private static string EscapeXmlComment(string text)
    {
        return text
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;");
    }

    /// <summary>
    /// Checks if a type name represents an interface type that doesn't need DynamicDependency.
    /// We use concrete MultiMap for dictionary-like types.
    /// </summary>
    private static bool IsInterfaceType(string typeName)
    {
        // Check for common interface patterns that we handle with MultiMap
        return typeName.Contains("IDictionary<") ||
               typeName.Contains("IReadOnlyDictionary<") ||
               typeName.Contains("ILookup<");
    }

    /// <summary>
    /// Checks if a type name is an assembly-qualified name (has comma outside of generic brackets).
    /// </summary>
    private static bool IsAssemblyQualifiedName(string typeName)
    {
        return FindAssemblyQualifierComma(typeName) >= 0;
    }

    /// <summary>
    /// Finds the index of the comma that separates type name from assembly name,
    /// ignoring commas inside generic type parameters.
    /// </summary>
    private static int FindAssemblyQualifierComma(string typeName)
    {
        var depth = 0;
        for (var i = 0; i < typeName.Length; i++)
        {
            var c = typeName[i];
            if (c == '<')
            {
                depth++;
            }
            else if (c == '>')
            {
                depth--;
            }
            else if (c == ',' && depth == 0)
            {
                // Found a comma at the top level (not inside generic brackets)
                return i;
            }
        }

        return -1; // No assembly qualifier comma found
    }
}
